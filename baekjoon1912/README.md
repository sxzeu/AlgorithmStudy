## 백준 1912 연속합(C++/DP)

### 문제 [문제보기](https://www.acmicpc.net/problem/1912)
 - n개의 정수로 이루어진 임의의 수열이 주어진다. 
 - 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 
 - 단, 수는 한 개 이상 선택해야 한다.
 - 예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 
 - 여기서 정답은 12+21인 33이 정답이 된다.

### 입력
 - 첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 
 - 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

### 출력
 - 첫째 줄에 답을 출력한다.

### 풀이법
 - 다이나믹 프로그래밍을 이용해 풀 수 있다.
 - 입력받는 배열 in 과 연속합을 기록할 배열 d가 필요하다.
 - 첫 번쨰로 사용자로부터 원하는 갯수만큼 배열 in에 입력 배열을 입력받는다.
 - 두 번쨰로 메모이제이션 할 배열 d의 값을 모두 d[i]= in[i]로 초기화한다. 
 - 만약 d[n-1]+in[n]이 d[n]보다 크다면 d[n]은 in[n]로 대체되어야 문제에서 주어진 연속합의 최댓값을 구할 수 있다.
 - 또한 기록해 둔 최댓값(초기 값은 가장 첫 번쨰 입력값)보다 크다면 최댓값을 갱신시켜준다. 


### 코드
```
#include <iostream>
using namespace std;

int in[100001];
int d[100001];

int main() {
	int n;
	int sum;

	cin >> n;
	for (int i = 0; i < n; i++) {

		cin >> in[i];
		d[i] = in[i];
	}

	sum = in[0];

	for (int i = 0; i < n; i++) {

		d[i] = in[i];
		if (i == 0) continue;
		if (d[i] < d[i -1] + in[i]) {
			d[i] = d[i - 1] + in[i];
		}

		if (d[i] > sum) sum = d[i];
	}
	cout << sum << '\n';
  return 0;
}
```
