## 백준 10844 쉬운 계단 수 (C/DP)

### 문제 [문제보기](https://www.acmicpc.net/problem/10844)
- 45656이란 수를 보자.
- 이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.
- N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 
- 0으로 시작하는 수는 계단수가 아니다.

### 입력
- 첫째 줄에 N이 주어진다. 
- N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

### 출력
 - 첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.


### 풀이법
 - 2차원 다이나믹 프로그래밍을 이용해 풀 수 있는 문제이다.
 - 2차원 배열을 하나 만든다. d[101][11] 101인 이유는 입력할 수 있는 수가 100이 최대이므로, 11인 이유는 0~9까지 10개의 숫자가 올 수 있으므로이다.
 - 따라서 d[2][3]은 길이가 2인 계단수를 만드는데, 현재 3을 사용중이라는 이야기가 된다.
 - 계단수의 경우에 대해서 생각해보자면, 1~8까지의 경우에는 1을 더하고 뺀 것이 모두 다음 자릿수로 나올 수 있다. 
 - 하지만 0과 9의 경우에는 다음 자릿수로 각각 1을 더하는 것, 1을 빼는 것만 가능하다.
 - 다이나믹 프로그래밍식으로 생각해보자면, d[n][i] = d[n-1][i-1]+d[n-1][i+1]이다.
 - 현재 채워야하는 자릿수가 n개가 남은 상황에서 현재 i를 사용하면, 앞으로 채워야할 자릿수는 n-1이 된다.
 - 이때 i+1과 i-1이 모두 나올 수 있으므로, 이때의 결과로 메모이제이션 한 값들을 가져와 사용한다.

### 코드
```
#include <stdio.h>

long d[101][11];

void dp(int n)
{
	for (int i = 1; i <= 9; i++) {
		d[1][i] = 1;
	}

	for (int i = 2; i <= n; i++) {
		d[i][0] = d[i - 1][1];
		for (int j = 1; j <= 9; j++) {
			d[i][j] = (d[i - 1][j - 1] + d[i - 1][j + 1]) % 1000000000;
		}
	}
}



int main()
{
	int n;
	scanf("%d", &n);

	dp(n);
	long output = 0;
	for (int i = 0; i <= 9; i++)
	{
		output += d[n][i];
	}
	printf("%ld", output % 1000000000);

}
```
