## 백준 1759 암호 만들기 (C++/brute force)

### 문제 [문제보기](https://www.acmicpc.net/problem/1759)
 - 바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보안 시스템을 설치하기로 하였다. 
 - 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.
 - 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 
 - 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다. 
 - 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.
 - 새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다. 
 - 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다. 
 - C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오.

### 입력
 - 첫째 줄에 두 정수 L, C가 주어진다. 
 - (3 ≤ L ≤ C ≤ 15) 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다. 
 - 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.
 
### 출력
 - 각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력한다.
 
### 풀이법
 - 입력받을 배열, 모음 여부를 체크하기 위한 배열, 출력을 위한 답안을 저장할 배열을 만든다.
 - 입력받은 배열을 sort함수를 통해 정렬한 후 dfs를 이용해 문제를 푼다.
 - dfs함수에서는 현재 입력중인 배열의 인덱스, 탐색을 시작하기 위해 이전에 탐색했던 인덱스, 현재 채워진 자음과 모음의 갯수를 넘긴다.
 - 현재 탐색중인 배열의 값이 자음이라면 dfs를 재귀로 호출할 때 자음+1, 모음은 그대로 넘겨준다.
 - 모음의 경우 반대로 진행한다.
 - 출력 배열의 길이가 입력했던 값에 도달하면, 모음이 1개 이상이고 자음이 2개 이상인지 확인한 후 출력한다.

### 코드
```
#include <iostream>
#include <algorithm>
using namespace std;

char arr[16];
bool aeiou[16] = { 0, };
char list[16];
int l, c;

void dfs(int x, int prev, int ja, int mo)
{
	if (x == l)
	{
		if (mo >= 1 && ja >= 2) {
			for (int i = 0; i < l; i++) cout << list[i];
			cout << "\n";
			return;
		}
	}

	for (int i = prev + 1; i < c; i++)
	{
		list[x] = arr[i];
		if (aeiou[i]) dfs(x + 1, i, ja, mo + 1);
		else dfs(x + 1, i, ja + 1, mo);
	}
}


int main()
{
	cin >> l >> c;
	for (int i = 0; i < c; i++) cin >> arr[i];
	sort(arr, arr + c);

	for (int i = 0; i < c; ++i) {
		if (arr[i] == 'a' || arr[i] == 'e' || arr[i] == 'i' || arr[i] == 'o' || arr[i] == 'u')
			aeiou[i] = true;
	}
	dfs(0, -1, 0, 0);
	return 0;
}
```
